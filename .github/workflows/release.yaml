name: Release Module

on:
  push:
    branches: [master]
    paths:
      - 'modules/**'
  workflow_dispatch:
    inputs:
      module_id:
        description: 'Module ID to release (leave empty for auto-detect)'
        required: false
        type: string

permissions:
  contents: write
  id-token: write
  attestations: write
  pages: write
  actions: read

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.detect.outputs.matrix }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 2

      - name: Detect changed modules
        id: detect
        run: |
          MODULES="[]"
          
          if [ -n "${{ inputs.module_id }}" ]; then
            # Manual dispatch with specific module
            MODULE_ID="${{ inputs.module_id }}"
            MODULE_PATH=$(find modules -type d -name "$MODULE_ID" | head -1)
            
            if [ -z "$MODULE_PATH" ] || [ ! -f "$MODULE_PATH/manifest.yaml" ]; then
              echo "::error::Module $MODULE_ID not found"
              exit 1
            fi
            
            VERSION=$(grep "^version:" "$MODULE_PATH/manifest.yaml" | awk '{print $2}')
            
            if [[ "$MODULE_PATH" == modules/abi/* ]]; then
              MODULE_TYPE="abi"
            elif [[ "$MODULE_PATH" == modules/container/* ]]; then
              MODULE_TYPE="container"
            elif [[ "$MODULE_PATH" == modules/grpc/* ]]; then
              MODULE_TYPE="grpc"
            fi
            
            MODULES=$(echo "$MODULES" | jq -c ". + [{\"module_id\": \"$MODULE_ID\", \"version\": \"$VERSION\", \"module_path\": \"$MODULE_PATH\", \"module_type\": \"$MODULE_TYPE\"}]")
          else
            # Auto-detect from git diff
            CHANGED_DIRS=$(git diff --name-only HEAD~1 HEAD | grep "^modules/" | cut -d/ -f1-3 | sort -u)
            
            for MODULE_PATH in $CHANGED_DIRS; do
              if [ -f "$MODULE_PATH/manifest.yaml" ]; then
                MODULE_ID=$(basename "$MODULE_PATH")
                VERSION=$(grep "^version:" "$MODULE_PATH/manifest.yaml" | awk '{print $2}')
                
                if [[ "$MODULE_PATH" == modules/abi/* ]]; then
                  MODULE_TYPE="abi"
                elif [[ "$MODULE_PATH" == modules/container/* ]]; then
                  MODULE_TYPE="container"
                elif [[ "$MODULE_PATH" == modules/grpc/* ]]; then
                  MODULE_TYPE="grpc"
                else
                  continue
                fi
                
                MODULES=$(echo "$MODULES" | jq -c ". + [{\"module_id\": \"$MODULE_ID\", \"version\": \"$VERSION\", \"module_path\": \"$MODULE_PATH\", \"module_type\": \"$MODULE_TYPE\"}]")
              fi
            done
          fi
          
          echo "matrix={\"include\":$MODULES}" >> "$GITHUB_OUTPUT"
          
          if [ "$MODULES" != "[]" ]; then
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
          fi

  build:
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
      fail-fast: false
    outputs:
      artifact_name: ${{ steps.build.outputs.artifact_name }}
      artifact_hash: ${{ steps.build.outputs.artifact_hash }}
      artifact_hash_base64: ${{ steps.build.outputs.artifact_hash_base64 }}
    steps:
      - uses: actions/checkout@v6

      - name: Setup Rust
        if: matrix.module_type == 'abi'
        uses: dtolnay/rust-toolchain@stable

      - name: Setup Go
        if: matrix.module_type == 'grpc'
        uses: actions/setup-go@v6
        with:
          go-version: '1.23'

      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake build-essential libssl-dev libmosquitto-dev protobuf-compiler

      - name: Install Go protoc plugins
        if: matrix.module_type == 'grpc'
        run: |
          go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.36.5
          go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.5.1

      - name: Build module
        id: build
        env:
          SOURCE_DATE_EPOCH: 0
          MODULE_PATH: ${{ matrix.module_path }}
          MODULE_ID: ${{ matrix.module_id }}
          MODULE_TYPE: ${{ matrix.module_type }}
        run: |
          cd "$MODULE_PATH"
          
          case "$MODULE_TYPE" in
            abi)
              if [ -f "Cargo.toml" ]; then
                cargo build --release
                ARTIFACT="target/release/lib${MODULE_ID}.so"
              elif [ -f "CMakeLists.txt" ]; then
                mkdir -p build && cd build
                cmake .. -DCMAKE_BUILD_TYPE=Release
                make
                cd ..
                ARTIFACT=$(find build -name "*.so" | head -1)
              else
                echo "::error::Unknown build system"
                exit 1
              fi
              ;;
            container)
              ARTIFACT="/tmp/${MODULE_ID}.tar.gz"
              tar -czf "$ARTIFACT" --exclude='*.tar.gz' .
              ;;
            grpc)
              if [ -f "go.mod" ]; then
                if [ -f "generate.sh" ]; then
                  chmod +x generate.sh
                  ./generate.sh
                fi
                CGO_ENABLED=0 go build -ldflags="-s -w" -o "${MODULE_ID}" .
                ARTIFACT="${MODULE_ID}"
              elif [ -f "Cargo.toml" ]; then
                cargo build --release
                ARTIFACT="target/release/${MODULE_ID}"
              else
                echo "::error::Unknown build system for grpc"
                exit 1
              fi
              ;;
          esac
          
          ARTIFACT_NAME="${MODULE_ID}-linux-amd64"
          cp "$ARTIFACT" "/tmp/${ARTIFACT_NAME}"
          
          HASH=$(sha256sum "/tmp/${ARTIFACT_NAME}" | cut -d' ' -f1)
          HASH_BASE64=$(echo "$HASH  $ARTIFACT_NAME" | base64 -w0)
          
          echo "artifact_name=${ARTIFACT_NAME}" >> "$GITHUB_OUTPUT"
          echo "artifact_hash=${HASH}" >> "$GITHUB_OUTPUT"
          echo "artifact_hash_base64=${HASH_BASE64}" >> "$GITHUB_OUTPUT"

      - name: Upload artifact
        uses: actions/upload-artifact@v5
        with:
          name: ${{ steps.build.outputs.artifact_name }}
          path: /tmp/${{ steps.build.outputs.artifact_name }}

  sign:
    needs: [detect-changes, build]
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
      fail-fast: false
    steps:
      - uses: actions/download-artifact@v6
        with:
          name: ${{ matrix.module_id }}-linux-amd64

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.10.1

      - name: Sign with Sigstore
        env:
          ARTIFACT: ${{ matrix.module_id }}-linux-amd64
        run: |
          cosign sign-blob "$ARTIFACT" \
            --yes \
            --new-bundle-format \
            --bundle "${ARTIFACT}.sigstore.json"

      - name: Upload signatures
        uses: actions/upload-artifact@v5
        with:
          name: ${{ matrix.module_id }}-linux-amd64-sigstore
          path: ${{ matrix.module_id }}-linux-amd64.sigstore.json

  release:
    needs: [detect-changes, build, sign]
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
      fail-fast: false
    steps:
      - uses: actions/checkout@v6

      - name: Download build artifact
        uses: actions/download-artifact@v6
        with:
          name: ${{ matrix.module_id }}-linux-amd64
          path: artifacts

      - name: Download signatures
        uses: actions/download-artifact@v6
        with:
          name: ${{ matrix.module_id }}-linux-amd64-sigstore
          path: artifacts

      - name: Create tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -f "${{ matrix.module_id }}-v${{ matrix.version }}"
          git push origin "${{ matrix.module_id }}-v${{ matrix.version }}" --force

      - name: Create release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ matrix.module_id }}-v${{ matrix.version }}
          files: artifacts/*
          generate_release_notes: true

  update-index:
    needs: [detect-changes, build, release]
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          ref: master

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install pyyaml

      - name: Update index for changed modules
        run: |
          MATRIX='${{ needs.detect-changes.outputs.matrix }}'
          echo "$MATRIX" | jq -c '.include[]' | while read -r item; do
            MODULE_ID=$(echo "$item" | jq -r '.module_id')
            VERSION=$(echo "$item" | jq -r '.version')
            MODULE_TYPE=$(echo "$item" | jq -r '.module_type')
            MODULE_PATH=$(echo "$item" | jq -r '.module_path')
            ARTIFACT_NAME="${MODULE_ID}-linux-amd64"
            
            ARTIFACT_HASH=$(curl -sL "https://github.com/${{ github.repository }}/releases/download/${MODULE_ID}-v${VERSION}/${ARTIFACT_NAME}" | sha256sum | cut -d' ' -f1)
            
            python scripts/update_index.py \
              --module-id "$MODULE_ID" \
              --version "$VERSION" \
              --module-type "$MODULE_TYPE" \
              --artifact-name "$ARTIFACT_NAME" \
              --artifact-hash "$ARTIFACT_HASH"
            
            cp "$MODULE_PATH/manifest.yaml" "pages/manifests/${MODULE_ID}.yaml"
          done

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add pages/index.yaml pages/manifests/
          git commit -m "Update index for changed modules" || true
          git push || true

  deploy-pages:
    needs: [detect-changes, update-index]
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - uses: actions/checkout@v6
        with:
          ref: master

      - name: Pull latest
        run: git pull

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: pages

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
